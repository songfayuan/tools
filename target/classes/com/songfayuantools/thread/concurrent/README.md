
*****************************************start********************************************

1.线程中断-->isInterrupted()方法可以得到线程的状态。
2.线程合并-->join() 所谓合并，就是等待其他线程执行完，再执行当前线程，执行起来的效果就好像把其他线程合并到当前线程执行一样。
3.线程睡眠-->sleep() 线程睡眠的过程中，如果是在synchronized线程同步内，是持有锁的，也就是说，线程是关门睡觉的，别的线程进不来。
4.线程让步-->yield()方法暂停当前正在执行的线程对象，并执行其他线程。
5.实现一个连环炸弹，2秒后爆炸一次，3秒后爆炸一次，如此循环下去。Timer是一种线程设施，用于安排以后在后台线程中执行的任务。可以安排执行一次，或者定期重复执行，可以看成一个定时器，可以调度TimerTask。TimerTask是一个抽象类，实现了Runnable接口，所以具备了多线程的能力。schedule是Timer调度任务的方法，Timer重构了四个schedule方法。
6.ScheduledThreadPool可以定时的或延时的执行任务
7.线程池
8.Callable接口类似于Runnable，但Runnable不会返回结果，并且无法抛出返回结果的异常。而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。
9.ExecutorService继承自Executor，他的目的是为我们管理Thread对象，从而简化并发编程，Executor使我们无需显示的去管理线程的生命周期。
10.执行多个带返回值的任务，并取得多个返回值。

【知识点】
1.在FixedThreadPool中，有一个固定大小的池，如果当前需要执行的任务超过了池大小,那么多余的任务处于等待状态，直到有空闲下来的线程执行任务，而当执行的任务小于池大小，空闲的线程也不会去销毁。
2.CachedThreadPool会创建一个缓存区，将初始化的线程缓存起来，如果线程有可用的，就使用之前创建好的线程，如果没有可用的，就创建新线程，终止并且从缓存中移除已有50秒未被使用的线程
3.SingleThreadExecutor得到的是一个单个的线程，这个线程会保证你的任务执行完成，如果当前线程意外终止，会创建一个新线程继续执行任务
4.ScheduledThreadPool可以定时的或延时的执行任务
5.Callable接口类似于Runnable，但Runnable不会返回结果，并且无法抛出返回结果的异常。而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。
6.ExecutorService继承自Executor，他的目的是为我们管理Thread对象，从而简化并发编程，Executor使我们无需显示的去管理线程的生命周期。

*****************************************end********************************************